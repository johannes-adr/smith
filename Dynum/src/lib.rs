use std::{borrow::Borrow, fmt::Display};


/// Informations about the supported types
struct DynumTypeInfo {
    tagsize: u8,
    tagcode: u8,
    bytecapacity: u8,
    bitrange: u8,
}

#[derive(Debug,Clone,Copy)]
pub enum DynumError{
    NoByteProvided,
    UnexpectedEOI{
        expected: u8,
        got: u8
    },
    NumberOutsideOfRange(u64),
    InvalidTag(u8)
}

impl Display for DynumError{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self{
            DynumError::UnexpectedEOI{expected,got} => write!(f,"Unexpected End of Input - Expected {expected} bytes, got {got}"),
            DynumError::InvalidTag(t) => write!(f,"First byte '{t:#010b}' doesnt have an valid Tag"),
            DynumError::NoByteProvided => write!(f,"No data provided"),
            DynumError::NumberOutsideOfRange(n) => write!(f,"Value {n} isnt inside range 2^{}",DynumType::max_value_info().bitrange),
        }
    }
}

impl std::error::Error for DynumError {}
/// Supported Integer Size
enum DynumType {
    Byte,
    Byte2,
    Byte4,
    Byte8,
}

impl DynumType {
    fn as_list() -> [DynumType; 4] {
        return [Self::Byte, Self::Byte2, Self::Byte4,Self::Byte8];
    }

    fn max_value() -> u64 {
        1 << Self::max_value_info().bitrange - 1
    }

    fn max_value_info() -> DynumTypeInfo{
        Self::as_list().last().unwrap().get_typeinfo()
    }

    const fn get_typeinfo(&self) -> DynumTypeInfo {
        match self {
            DynumType::Byte => DynumTypeInfo {
                tagsize: 1,
                tagcode: 0b001,
                bytecapacity: 1,
                bitrange: 7, //8 bit - tagsize
            },
            DynumType::Byte2 => DynumTypeInfo {
                tagsize: 2,
                tagcode: 0b010,
                bytecapacity: 2,
                bitrange: 14, //16 bit - tagsize
            },
            DynumType::Byte4 => DynumTypeInfo {
                tagsize: 3,
                tagcode: 0b100,
                bytecapacity: 4,
                bitrange: 29, //32 bit - tagsize
            },
            DynumType::Byte8 => DynumTypeInfo {
                tagsize: 3,
                tagcode: 0b000,
                bytecapacity: 8,
                bitrange: 61, //64 bit - tagsize
            },
        }
    }
}

/// This function encodes the given number using the dynamic number type that can represent it.
/// It takes the number and a closure that accepts a u8.
/// This closure gets called for every generated byte
/// It returns either the number of generated bytes or an error message if the given value exceeds the supported range.
pub fn encode_into(mut num: u64, mut target: impl FnMut(u8)) -> Result<u8,DynumError> {
    let typ = DynumType::as_list()
        .into_iter()
        .find(|d| {
            let info = d.get_typeinfo();
            num >> info.bitrange == 0
        })
        .ok_or(DynumError::NumberOutsideOfRange(num))?;

    let typdata = typ.get_typeinfo();

    //Insert tagdata
    num <<= typdata.tagsize;
    num |= typdata.tagcode as u64;

    let bts = num.to_le_bytes();
    for n in 0..typdata.bytecapacity {
        target(bts[n as usize])
    }
    Ok(typdata.bytecapacity)
}


/// Decode a binary stream into a u64 value using the appropriate dynamic number type.
/// Returns none if the first read byte doesn't contains a valid tag
pub fn decode_binary_stream<T: Borrow<u8>>(input: &mut impl Iterator<Item = T>) -> Result<u64,DynumError> {
    let first: u8 = *input.next().ok_or(DynumError::NoByteProvided)?.borrow();

    let typ = DynumType::as_list().into_iter().find(|d| {
        let info = d.get_typeinfo();
        let invts = 8 - info.tagsize;
        (first << invts) >> invts == info.tagcode
    }).ok_or(DynumError::InvalidTag(first))?;
    let typdata = typ.get_typeinfo();

    let mut buff = [0u8; std::mem::size_of::<u64>()];
    buff[0] = first;
    for i in 0..typdata.bytecapacity - 1 {
        buff[(i + 1) as usize] = *input.next()
        .ok_or(DynumError::UnexpectedEOI{
            expected: typdata.tagsize+typdata.bitrange,
            got: i+1
        })?.borrow();
    }

    //Remove tagdata and decode
    Ok(u64::from_le_bytes(buff) >> typdata.tagsize)
}


#[cfg(test)]
mod tests {
    use rayon::prelude::*;

    use super::*;

    #[inline(always)]
    fn test_for_i(i: u64){
        let mut buffi = 0;
        let mut buff = [0u8;8];
        encode_into(i, |a| {buff[buffi] = a;buffi+=1}).unwrap();
        let result = decode_binary_stream(&mut buff.iter()).unwrap();
        assert_eq!(i, result);
    }

    #[test]
    fn test_range_bot2up() {
        (0..1<<20).into_par_iter().for_each(test_for_i);
    }

    #[test]
    fn test_range_up2bot(){
        let maxval = DynumType::max_value();
        (0..1<< 20).into_par_iter().for_each(|i|{
            test_for_i(maxval - (i * 1<<32))
        })
    }

    #[test]
    fn test_example(){
        let mut buff = Vec::with_capacity(10);
        let val = 1234567890;
        encode_into(val, |a| buff.push(a)).unwrap();
        let decoded_val = decode_binary_stream(&mut buff.iter().cloned()).unwrap();
        assert_eq!(val, decoded_val);
    }
}